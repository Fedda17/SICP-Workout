Blackjack project.
Rules of the game.
Two Players wich purpose is getting at 21 through a set of cards
Players are dealer and costumer
For programming purpose, the cards are made by words
Jack = j
King = k
Ace = a
Queen = q
Spades = s
Hearts = h
Clubs = c
Diamonds = d

Picture cards = 10p
Ace = 1p or 11p

Cards are reshuffled at each round

At each round at the start the players are dealt with two cards and one of the dealer's is facing up
The dealer's rules are:
if cards < 17 takes otherwise stops
The costumer plays before the dealer.
If costumer cards > 21 -> immediate lost
If costumer's cards = dealer's cards -> tie

Costumer's strategy = f(hand-so-far, dealers-faceup-card) -> true or false, instruct whether to take another card


hand-so-far = sentence of words
dealers-faceup-card = words


library function: twenty-one, if I feed it "strategy" it plays a game with randomly shuffled cards and returns 0 or 1 or -1
if 1 the costumer won
if 0 tie
if -1 costumer lost 

My purpose of this program is to do some testing for to-do procedures indicated in the text using trace output and convince the reader that it works

Let's start by importing the library function to racket 

I have to define a procedure best-total with input a sentence of cards and output the total points
I should return the closest number less or equal to 21 when ace is in the sentence

Writing and test of the procedure:

procedure that returns a sentence of points ordered.
sum ordered points accounting for ace value


(define (best-total hand)
	(define (points-association card) 
			(let ((card-rank (bl card)))
				(cond ((and (number? card-rank) (< card-rank 11)) card-rank)
							((or (equal? card-rank 'J) (equal? card-rank 'Q) (equal? card-rank 'K)) 10)
							((equal? card-rank 'A) 11)
				)
			)
	)

	(define (sum-best-total ordered-points total) 
		(define MAX-POINTS 21)
		 (cond
						((empty? ordered-points) total)
						((and (= 11 (first ordered-points)) (> total (- MAX-POINTS 11))) (sum-best-total (bf ordered-points) (+ total 1)))
						(else (sum-best-total (bf ordered-points) (+ total (first ordered-points))))
		
		  )
	)

	(define (iter-points hand)
		(cond ((empty? hand) '())
			  (else (sentence (points-association (first hand)) (iter-points (bf hand))))
		) 
	)

	(sum-best-total (sort (iter-points hand) <) 0)
)
	
Part 2 I have to write a procedure that does the same but for the dealer, I expect to reuse a lot of code:
(define (stop-at-17 customer-hand-so-far dealer-card-facing-up)
	(< (best-total  customer-hand-so-far) 17)
) 

This stack should provide enough evidence that the procedure works, if there are any bugs anyway, the best-total and stop-at-17 definitions become
faulty as a consequence because they rely on the same definitions.

Now for play-n:

(define (play-n strategy n)
		(if (> n 0) (+ (twenty-one strategy) (play-n strategy (- n 1))) 0)) 
	
For the dealer sensitive strategy, there are two cases:
I return true when the dealer facing up card is 7 or 8 or 9 or 10 or ace or picture and the customer has less than 17
I return false when the dealer has 2 or 3 or 4 or 5 or 6 and the customer has less than 12

(define (dealer-sensitive customer-hand-so-far dealer-card-facing-up)
		(cond ((> (best-total (sentence dealer-card-facing-up '())) 6) (< (best-total customer-hand-so-far) 17))
				(else (< (best-total customer-hand-so-far) 12)))
)

The stack trace provides:

For stopping at strategy, should be pretty straightforward:
(define (stop-at n)
	(lambda (customer-hand-so-far dealer-card-facing-up)
		(< (best-total  customer-hand-so-far) n))
 )
 

Now for the valentine strategy:
(define (valentine customer-hand-so-far dealer-card-facing-up)
	(define (contains-hearts? hand) 
		(let ((suit-card (lambda (card) (last card))))
			(cond
				((empty? hand) #f)
				((equal? (suit-card (first hand)) 'H) #t)
				(else (contains-hearts? (bf hand))))
		))
	(let ((aggressiveness (stop-at 19))
		  (normal (stop-at 17))) 
		((if (contains-hearts? customer-hand-so-far) aggressiveness 
											         normal) customer-hand-so-far '()))
)



Point 7 tells me to generalize the procedure "valentine" with a procedure of three arguments:
A suit, a normal strategy, and a tailored strategy for when the hand contains the suit.


(define (suit-strategy suit tailored-strategy normal-strategy)
	(lambda (customer-hand-so-far dealer-card-facing-up)
		(trace-define (contains-suit? hand) 
		(let ((suit-card (lambda (card) (last card))))
			(cond
				((empty? hand) #f)
				((equal? (suit-card (first hand)) suit) #t)
				(else (contains-suit? (bf hand))))
		)) 
		((if (contains-suit? customer-hand-so-far) tailored-strategy 
											         normal-strategy) customer-hand-so-far '())
	)
)


by seeing the stack trace:


Part 8.

Procedure named majority.
Domain: three strategies (procedures)
Range: a strategy (procedure)
the result strategy returns true if 2 or 3 domain strategies do it

(define (majority strategy1 strategy2 strategy3)
	(lambda (customers-cards-so-far dealers-card-facing-up)
		(let ((majority-tactic (lambda (strategy) (if (strategy customers-cards-so-far dealers-card-facing-up) 1 0))))
			(> (+ (majority-tactic strategy1) (majority-tactic strategy2) (majority-tactic strategy3)) 1))
	)
)