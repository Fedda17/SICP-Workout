I need to show that sum and product can be still generalized with a higher order procedure that I'll call accumulate.
Recall the definitions of sum and product:

(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))

(define (product term a next b)
  (if (> a b)
      1
      (* (term a)
         (product term (next a) next b))))
Under the book suggestion, I replace the common patterns with slots

(define (<name> term a next b)
	(if (> a b)
	<null-value>
	(<combiner>  (term a) (<name> term (next a) next b))))
	
And change those slots with formal parameters
(define (accumulate null-value combiner term a next b)
	(if (> a b) 
		null-value 
		(combiner (term a) (accumulate null-value combiner term (next a) next b))))
With this definition, I'll rewrite both sum and product simply as:

(define (sum term a next b) 
	(accumulate 0 + term a next b))
	
(define (product term a next b) 
	(accumulate 1 * term a next b))
	
--- Test POSITIVE

Part 2:
Turn accumulate procedure into a procedure which generates a iterative process:

(define (accumulate null-value combiner term a next b)
  (define (accumulate-iter result a)
	  (if (> a b) 
		  result 
      (accumulate-iter (combiner result (term a))  (next a))))
      (accumulate-iter null-value a))