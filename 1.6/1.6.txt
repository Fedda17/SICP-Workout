Conclusione:
L'ordine di calcolo applicativo seguito dall'interprete in Scheme calcola prima le espressioni della combinazione (new-if predicate then-clause else-clause) all'interno della procedura sqrt-iter, il che nasconde la forma speciale che il simbolo if e cond hanno nel linguaggio nelle quali il calcolo di un'espressione è determinato da un predicato.

Definisco la procedura new-if come un "sostituto" di if e la registro nell'ambiente:

(define (new-if predicate 
                then-clause 
                else-clause)
  (cond (predicate then-clause)
        (else else-clause)))
		
Considero il caso in cui è usata in questa definizione:

(define (sqrt-iter guess x)
  (new-if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x) x)))
		  
		
Provando a fare una prova con la procedura sqrt, che è ricorsiva, l'interprete non risponde andando in timeout.
Cosa succede?

Proviamo con una semplice sostituzione---
(define (sqrt-iter guess x)
  (cond ((good-enough? guess x) guess)
          (else  (sqrt-iter (improve guess x) x))))
		  
La mia teoria è che ci mette troppo tempo a sostituire la definizione, ma come la testo? Potrei andare a cercare una funzione di libreria che stampi la funzione ad ogni iterazione. Usando la funzione trace che traccia l'evoluzione del processo, noto che non si ferma mai, quindi presuppongo che la mia teoria è sbagliata con il parametro guess che si ferma allo stesso valore corretto.
Se uso un if normale e ripeto lo stesso esperimento? Noto dei cambiamenti nell'evoluzione del processo, e il procedimento raggiunge una conclusione cambiando il parametro "guess", quindi la mia teoria è sbagliata, devo fare un cambio di ipotesi...
La differenza tra sqrt-iter implementato con new-if e quello implementato con if è che entrambi calcolano il risultato correttamente ma il new-if non fa fermare mai il processo, quindi c'è qualcosa nel new-if che restituisce sempre il sqrt-iter come condizione, forse perché l'else è una condizione che dà sempre true?
Mi fermo con lo stipulare che c'è qualcosa di come l'interprete calcola la forma speciale di "if" che fa terminare il processo quando dà true nell'ultima iterazione e invece il cond fa ripetere all'infinito l'ultima iterazione
fino a che non scopro qualcosa di pertinente leggendo il libro.


  Immagino cosa fa il cond nell'ultima iterazione in Lisp:
    (cond ( (good-enough? 3.354 9) guess)
        (else (cond ((good-enough? 3.000818 9) 3)
          (else  (sqrt-iter (improve 3 9) 9)))))

Ho pensato male, qui il cond con il predicato a true, è una serie di espressioni, ma la serie di espressioni talvolta consiste in cond annidati grazie
alla ricorsione sulla funzione stessa, quindi è vero che l'ultimo valore nella serie d'espressioni è "3" ma è praticamente il valore che 
solo il cond più "annidato", e a causa della natura del cond non può essere il valore dell'intera espressione perché il cond sopra ha come valore (sqrt-iter (improve guess x) guess).
Quindi l'intreprete non scioglierà mai quest'ultimo passaggio per la natura ricorsiva della procedura.

Ipotesi sbagliata: facendo un test è chiaro che l'iterazione infinita aggiorna sempre il valore di guess, solo che ad una certa non riesce più a farlo con una precisione, ma comunque ritorna true dopo aver stabilito una certa precisione
nonostante ritorna true il processo non termina. L'aggiorno dicendo che mantengo il fatto che l'else del penultimo cond annidato viene comunque eseguito

Se uso il cond "direttamente" nella definizione di sqrt-iter:
(define (sqrt-iter guess x)
  (cond ((good-enough? guess x)
          guess)
          (else (sqrt-iter (improve guess x) x))))

Il processo finisce il compito, quindi da questo deduco che definire la procedura new-if causa il problema che potrebbe dipendere dall'interprete che segue l'ordine di calcolo applicativo.

Definizione usate:

(define (improve x y)  (average x (/ y x)))

(define (average x y) 
  (/ (+ x y) 2))
  
  (define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))
	  
