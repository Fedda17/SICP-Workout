Conclusione:

Ho notato di come il processo del computer abbia bisogno di sapere, indicato tramite un margine nella procedura, quando è sufficiente fermarsi
attraverso una tolleranza stabilita matematicamente partendo dalle premesse dell'esercizio 1.6:

(- frazione molto piccola + guess) < (improve guess x) < (frazione molto piccola + guess)



L'esercizio 1.7 assume che la procedura good-enough? definita con:

(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))
  
 Non è adatta per grandi e piccoli numeri per la capacità limitata del computer di esprimere accuratamente le operazioni matematiche.
 Mi invita poi a fare dei test usando la procedura e traendone conclusioni. Facendo dei test con la procedura good-enough, mi pare che sia infallibile con numeri grandi, ho provato fino a circa 10^50, 
 invece mi pare che il problema nasce quando il test deve comporre un blocco per trarre dei numeri iterativamente più vicini al valore che vuole la procedura, per questo l'esercizio mi dice di approssimare
 con la consapevolezza che i computer prendono scorciatoie per scappare dalla perfezione, perché richiederebbe un processo infinito. Dunque mi suggerisce di alterare la procedura good-enough in modo che riesca a dire che 
 l'approssimazione è sufficiente per ricavare la radice quadra di un numero grande. Suggerisce di usare una tolleranza che corrisponde a (- frazione molto piccola + guess) < (improve guess x) < (frazione molto piccola + guess)
 
 
 Allora applicando questa nuova ipotesi alla procedura good-enough la cambio in:
 (define (good-enough? guess x)
  (< (abs  (- (improve  guess x) guess))   0.0000000001))
  
  Insomma la "tolleranza" che usa questa nuova funzione è calibrata attorno a quanto il variamento di guess diventa sufficientemente irrisorio procedendo con l'iterazione
  
  
  DEFINIZIONI USATE:
  
(define (improve x y)  (average x (/ y x)))

(define (average x y) 
  (/ (+ x y) 2))
  
  (define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))
  

  Per testare la correttezza di good-enough:

  (define (sqrt-iter guess x)
  (if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x) x)))
		  
